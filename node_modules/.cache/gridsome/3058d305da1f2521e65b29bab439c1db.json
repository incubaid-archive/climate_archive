{"remainingRequest":"/home/ehab/codewww/github/threefoldfoundation/www_climate_action_project/node_modules/babel-loader/lib/index.js??ref--1-1!/home/ehab/codewww/github/threefoldfoundation/www_climate_action_project/node_modules/gridsome-plugin-flexsearch/gridsome.client.js","dependencies":[{"path":"/home/ehab/codewww/github/threefoldfoundation/www_climate_action_project/node_modules/gridsome-plugin-flexsearch/gridsome.client.js","mtime":499162500000},{"path":"/home/ehab/codewww/github/threefoldfoundation/www_climate_action_project/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/ehab/codewww/github/threefoldfoundation/www_climate_action_project/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import FlexSearch from 'flexsearch';\nimport cjson from 'compressed-json';\nimport pMap from 'p-map';\nexport default async function (Vue, options, {\n  isClient,\n  router\n}) {\n  const {\n    flexsearch,\n    chunk = false,\n    compress = false,\n    autoFetch = true,\n    autoSetup = true,\n    searchFields,\n    pathPrefix,\n    siteUrl\n  } = options;\n\n  if (isClient) {\n    const basePath = pathPrefix && (process.env.NODE_ENV !== 'development' || location.origin === siteUrl) ? `${pathPrefix}/flexsearch` : '/flexsearch'; // Data fetch functions\n\n    const loadNormalMode = async search => {\n      let searchIndex = await fetch(`${basePath}.json`).then(r => r.json());\n      if (compress) searchIndex = cjson.decompress(searchIndex);\n      search.import(searchIndex, {\n        serialize: false\n      });\n    };\n\n    const loadChunkMode = async search => {\n      const {\n        index,\n        docs\n      } = await fetch(`${basePath}/manifest.json`).then(r => r.json());\n\n      const fetchData = id => fetch(`${basePath}/${id}.json`).then(r => r.json()).then(j => compress ? cjson.decompress(j) : j);\n\n      const searchIndex = await pMap(index, fetchData);\n      search.import(searchIndex, {\n        index: true,\n        doc: false,\n        serialize: false\n      });\n      let searchDocs = {};\n\n      for await (const id of docs) {\n        const data = await fetchData(id);\n        searchDocs = { ...searchDocs,\n          ...Object.fromEntries(data)\n        };\n      }\n\n      search.import([searchDocs], {\n        index: false,\n        doc: true,\n        serialize: false\n      });\n    }; // Manually setup the Flexsearch instance\n\n\n    if (!autoSetup) {\n      Vue.prototype.$flexsearch = {\n        flexsearch: { ...flexsearch,\n          doc: {\n            id: 'id',\n            field: searchFields\n          }\n        },\n        basePath,\n        loadIndex: loadNormalMode\n      };\n      return;\n    } // Setup global Flexsearch Instance\n\n\n    const search = new FlexSearch({ ...flexsearch,\n      doc: {\n        id: 'id',\n        field: searchFields\n      }\n    });\n    Vue.prototype.$search = search;\n    Vue.prototype.$searchOptions = {\n      basePath\n    };\n    if (!autoFetch) return;\n\n    if (typeof autoFetch === 'string' || typeof autoFetch === 'object') {\n      let loaded = false;\n      const pathsToLoad = typeof autoFetch === 'string' ? [autoFetch] : autoFetch;\n      return router.afterEach(({\n        path: currentPath\n      }) => {\n        if (pathsToLoad.includes(currentPath) && !loaded) {\n          loaded = true;\n          return chunk ? loadChunkMode(search) : loadNormalMode(search);\n        }\n      });\n    } else if (chunk) return loadChunkMode(search);else return loadNormalMode(search);\n  }\n}",null]}